/*

Strings From Wild Card





Problem Statement:



You are given string s of length n, having m wildcard characters '?', where each wildcard character represent

a single character. Write a program which returns list of all possible distinct strings that can be generated by replacing each wildcard characters in s with either '0' or '1'.



Any string in returned list must not contain '?' character i.e. you have to replace all '?' with either '0' or '1'.



The purpose of this problem is to learn recursion and not DP. So, you must write at least one recursive solution. After that, you can write a DP solution if you want.



Input Format:



There is only one argument s, denoting input string.



Output Format:



Return a result list of distinct strings (No fix order of strings in result list is required).



Constraints:



1 <= n <= 50, where n is length of s.
0 <= m <= 17, where m is number of ‘?’ (wildcard characters) in s.


Sample Test Cases:



Sample Test Case 1:



Sample Input 1:



s = “1?10”



Sample Output 1:



result = ["1010", "1110"] or ["1110", "1010"].



Explanation 1:



‘?’ at index 1 (0 based indexing) can be replaced with either '0' or '1'. So, generated two strings replacing '?' with ‘0’ and ‘1’.



Sample Test Case 2:



Sample Input 2:



s = “1?0?”



Sample Output 2:



result = ["1000", "1001", "1100", "1101"] or any other list having same strings but in different order.



Explanation 2:



Input string have two '?' characters. Each one can be replaced with either '0' or '1'. So, total 2*2 strings are possible as ('?' at index 1, '?' at index 3) can be replaced with ('0','0'), ('0','1'), ('1', '0'), ('1', '1').

void genAllStrings(string &s, int i, vector<string> &ret)
{
	if (i == s.size()) {
		ret.push_back(s);
		return;
	}

	char c = s[i];
	if (c == '?') {
		s[i] = '0';
		genAllStrings(s, i + 1, ret);
		s[i] = '1';
		genAllStrings(s, i + 1, ret);
		s[i] = c;
		return;
	}

	genAllStrings(s, i + 1, ret);
}

vector<string> find_all_possibilities(string s) {
	vector<string> ret;
	int i = 0;

	genAllStrings(s, i, ret);

	return ret;
}

*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

void find_all_possibilities_rec(string s, int i, vector<string>& res)
{
	if (i == s.length())		//Base condition: Index i is incremented to the end of the string
	{								//Thus we store the resultant combination to res and return
		res.push_back(s);
		return;
	}

	if (s[i] == '?')			//Is char is wild card '?'
	{
		s[i] = '0';				//First change it to '0'
		cout << "? BEFORE s0 = " << s << ", i = " << i << endl;
		find_all_possibilities_rec(s, i+1, res);		//Increment index to find more '?'
		cout << "? AFTER s0 = " << s << ", i = " << i << endl;
		s[i] = '1';				//Once all '?' --> 0 replaces are done return get back us to where we can choose now to replace with '1' 
		cout << "? BEFORE s1 = " << s << ", i = " << i << endl;
		find_all_possibilities_rec(s, i+1, res);	//Increment index to find more '?'
		cout << "? AFTER s1 = " << s << ", i = " << i << endl;
	}
	else
	{
		cout << "ELSE BEFORE s = " << s << ", i = " << i << endl;
		find_all_possibilities_rec(s, i+1, res);	//If not '?' then just increment index i
		cout << "ELSE AFTER s = " << s << ", i = " << i << endl;
	}
}

/*
 * Complete the find_all_possibilities function below.
 */
vector<string> find_all_possibilities(string s) {
	/*
	 * Write your code here.
	 */

	vector<string> res;			//Will hold resultant distinct string combinations
	int i = 0;					//index of the string which we will keep on incrementing during recursion

	find_all_possibilities_rec(s, i, res);
	return res;
}

int main()
{
	ostream &fout = cout;

	string s;
	getline(cin, s);

	vector<string> res = find_all_possibilities(s);

	for (int res_itr = 0; res_itr < res.size(); res_itr++) {
		fout << res[res_itr];

		if (res_itr != res.size() - 1) {
			fout << "\n";
		}
	}

	fout << "\n";
	
	system("pause");
	return 0;
}

